<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.0.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon2.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon2.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon2.png"><link rel="mask-icon" href="/images/favicon2.png" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"daydayup863.github.io",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"right",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!0,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!0,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"bounceIn",post_header:"slideDownIn",post_body:"perspectiveRightIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="缓冲区管理器管理共享内存和持久性存储之间的数据传输，并且可能对DBMS的性能产生重大影响。 PostgreSQL缓冲区管理器非常高效。在本章中，将介绍PostgreSQL缓冲区管理器。第一部分提供了概述，随后的部分描述了以下主题：  Buffer manager structure Buffer manager locks How the buffer manager works Ring buf"><meta property="og:type" content="article"><meta property="og:title" content="PostgreSQL 缓冲区管理"><meta property="og:url" content="http://daydayup863.github.io/PostgreSQL/PostgreSQL_Buffer_Manager/index.html"><meta property="og:site_name" content="daydayup863"><meta property="og:description" content="缓冲区管理器管理共享内存和持久性存储之间的数据传输，并且可能对DBMS的性能产生重大影响。 PostgreSQL缓冲区管理器非常高效。在本章中，将介绍PostgreSQL缓冲区管理器。第一部分提供了概述，随后的部分描述了以下主题：  Buffer manager structure Buffer manager locks How the buffer manager works Ring buf"><meta property="og:locale"><meta property="og:image" content="http://daydayup863.github.io/images/pg_buffer_manager.png?150x100"><meta property="og:image" content="http://daydayup863.github.io/images/pg_buffer_manager_2.png"><meta property="og:image" content="http://daydayup863.github.io/images/pg_buffer_manager_3.png"><meta property="og:image" content="http://daydayup863.github.io/images/pg_buffer_manager_4.png"><meta property="og:image" content="http://daydayup863.github.io/images/pg_buffer_manager_5.png"><meta property="og:image" content="http://daydayup863.github.io/images/pg_buffer_manager_6.png"><meta property="og:image" content="http://daydayup863.github.io/images/pg_buffer_manager_7.png"><meta property="og:image" content="http://daydayup863.github.io/images/pg_buffer_manager_8.png"><meta property="og:image" content="http://daydayup863.github.io/images/pg_buffer_manager_9.png"><meta property="og:image" content="http://daydayup863.github.io/images/pg_buffer_manager_10.png"><meta property="article:published_time" content="2020-08-20T03:21:12.000Z"><meta property="article:modified_time" content="2021-03-05T08:30:47.555Z"><meta property="article:author" content="daydayup"><meta property="article:tag" content="PostgreSQL"><meta property="article:tag" content="buffer"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://daydayup863.github.io/images/pg_buffer_manager.png?150x100"><link rel="canonical" href="http://daydayup863.github.io/PostgreSQL/PostgreSQL_Buffer_Manager/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-Hans"}</script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><style>#needsharebutton-float{bottom:88px;cursor:pointer;left:-8px;position:fixed;z-index:9999}#needsharebutton-float .btn{border:1px solid $btn-default-border-color;border-radius:4px;padding:0 10px 0 14px}</style><title>PostgreSQL 缓冲区管理 | daydayup863</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><script type="text/javascript" src="/js/bubble.js"></script><link rel="alternate" href="/atom.xml" title="daydayup863" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><a target="_blank" rel="noopener" href="https://github.com/daydayup863"><img style="position:fixed;top:0;right:0" width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_right_gray_6d6d6d.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">daydayup863</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">人生就像一杯茶，不会苦一辈子，但总会苦一阵子。</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-messagepad"><a href="/messagepad/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>留言板</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans"><link itemprop="mainEntityOfPage" href="http://daydayup863.github.io/PostgreSQL/PostgreSQL_Buffer_Manager/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/user.jpg"><meta itemprop="name" content="daydayup"><meta itemprop="description" content="good good study, day day up."></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="daydayup863"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">PostgreSQL 缓冲区管理</h1><div class="post-meta"><i class="fa fa-thumbtack"></i> <font color="7D26CD">置顶</font> <span class="post-meta-divider">|</span> <span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-08-20 11:21:12" itemprop="dateCreated datePublished" datetime="2020-08-20T11:21:12+08:00">2020-08-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/PostgreSQL/" itemprop="url" rel="index"><span itemprop="name">PostgreSQL</span></a> </span></span><span id="/PostgreSQL/PostgreSQL_Buffer_Manager/" class="post-meta-item leancloud_visitors" data-flag-title="PostgreSQL 缓冲区管理" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/PostgreSQL/PostgreSQL_Buffer_Manager/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/PostgreSQL/PostgreSQL_Buffer_Manager/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><p>缓冲区管理器管理共享内存和持久性存储之间的数据传输，并且可能对DBMS的性能产生重大影响。 PostgreSQL缓冲区管理器非常高效。<br>在本章中，将介绍PostgreSQL缓冲区管理器。第一部分提供了概述，随后的部分描述了以下主题：</p><ul><li>Buffer manager structure</li><li>Buffer manager locks</li><li>How the buffer manager works</li><li>Ring buffer</li><li>Flushing of dirty pages<a id="more"></a> <img data-src="/images/pg_buffer_manager.png?150x100" alt="Relations between buffer manager, storage, and backend processes."></li></ul><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>本节介绍了有助于在后续各节中进行描述的关键概念。</p><h2 id="Buffer-Manager-Structure"><a href="#Buffer-Manager-Structure" class="headerlink" title="Buffer Manager Structure"></a>Buffer Manager Structure</h2><p>PostgreSQL缓冲区管理器包含一个缓冲区表，缓冲区描述符和缓冲池，这将在下一节中介绍。缓冲池层存储数据文件页面，例如表和索引，以及自由空间映射和可见性映射。缓冲池是一个数组，即每个插槽存储一个数据文件的一页。缓冲池阵列的索引称为buffer_id。</p><h2 id="Buffer-Tag"><a href="#Buffer-Tag" class="headerlink" title="Buffer Tag"></a>Buffer Tag</h2><p>在PostgreSQL中，每一个数据文件的每一个页面分配了一个唯一的标签，即buffer tag。当缓冲区管理器收到请求时，PostgreSQL会使用目标页面的buffer_tag</p><p>buffer_tag包含三个值：其页面所属relation的RelFileNode和fork number，以及其页面的块编号。表，空闲空间映射和可见性映射的派生编号分别在0、1和2中定义。</p><p>例如，buffer_tag’{（16821，16384，37721），0，7}’ 表示这个页面位于relation中数据页面的第七块页面，relation的OID和派生编号分别为37721和0；在OID为16821的表空间下，其OID为16384的数据库中。<br>类似地，buffer_tag’{（16821，16384，37721），1，3}’ 表示这个页面位于relation中的freespace map页面第三个页面，relation的OID和派生编号分别为37721和1; 在OID为16821的表空间下，其OID为16384的数据库中。</p><h2 id="How-a-Backend-Process-Reads-Pages"><a href="#How-a-Backend-Process-Reads-Pages" class="headerlink" title="How a Backend Process Reads Pages"></a>How a Backend Process Reads Pages</h2><p>本小节描述了后端进程如何从缓冲区管理器读取页面<br><img data-src="/images/pg_buffer_manager_2.png" alt="How a backend reads a page from the buffer manager.."></p><ul><li>读取表或索引页时，后端进程会将包含页面的buffer_tag的请求发送到缓冲区管理器.</li><li>缓冲区管理器返回存储请求页面的插槽的buffer_ID。如果请求的页面未存储在缓冲池中，则缓冲管理器将页面从持久性存储加载到缓冲池插槽之一，然后返回buffer_ID的插槽</li><li>后端进程访问buffer_ID的插槽（以读取所需的页面</li></ul><p>当后端进程修改缓冲池中的页面（例如，通过插入元组）时，尚未刷新到存储的修改后的页面称为脏页面。</p><h2 id="Page-Replacement-Algorithm"><a href="#Page-Replacement-Algorithm" class="headerlink" title="Page Replacement Algorithm"></a>Page Replacement Algorithm</h2><p>当所有缓冲池插槽均被占用但未存储请求的页面时，缓冲管理器必须在缓冲池中选择一个页面，该页面将由请求的页面替换。通常，在计算机科学领域中，页面选择算法称为页面替换算法，而所选页面称为受害者页面<br>自计算机科学问世以来，一直在进行页面替换算法的研究。因此，先前已经提出了许多替换算法。从8.1版开始，PostgreSQL使用了clock-sweep，因为它比以前版本中使用的LRU算法更简单，更高效。<br>4.4节详细介绍了时钟扫描</p><h2 id="Flushing-Dirty-Pages"><a href="#Flushing-Dirty-Pages" class="headerlink" title="Flushing Dirty Pages"></a>Flushing Dirty Pages</h2><p>脏页最终应刷新到存储中；但是，缓冲区管理器需要帮助才能执行此任务。在PostgreSQL中，两个后台进程（checkpointer和background writer）负责此任务。</p><p>第6节介绍了checkpointer和background writer</p><p><strong>Direct I/O</strong><br>PostgreSQL不支持direct I/O，尽管已经讨论过了。如果您想了解更多详细信息，请参考<a target="_blank" rel="noopener" href="https://www.postgresql.org/message-id/529E267F.4050700@agliodbs.com">pgsql-ML</a>和这篇<a target="_blank" rel="noopener" href="https://lwn.net/Articles/580542/">文章</a>。</p><h1 id="Buffer-Manager-Structure-1"><a href="#Buffer-Manager-Structure-1" class="headerlink" title="Buffer Manager Structure"></a>Buffer Manager Structure</h1><p>PostgreSQL缓冲区管理器包括三层，即缓冲区表(buffer table)，缓冲区描述符(buffer descriptors)和缓冲池(buffer pool)</p><p><img data-src="/images/pg_buffer_manager_3.png" alt="Fig. 8.3. Buffer manager&#39;s three-layer structure."></p><ul><li>缓冲池是一个数组。每个插槽存储一个数据文件页面。阵列插槽的索引称为bufferids</li><li><p>缓冲区描述符层是缓冲区描述符的数组。每个描述符与缓冲池插槽一一对应，并在相应的插槽中保存存储页面的元数据。</p><hr><p><strong>Note</strong></p><p>为方便起见，采用术语“缓冲区描述符层”，并且仅在本文档中使用。</p><hr></li><li><p>缓冲区表是一个哈希表，用于存储存储页的buffer_tags与保存存储页各自元数据的描述符的buffer_id之间的关系。</p></li></ul><p>这些层将在以下章节中详细介绍</p><h2 id="Buffer-Table"><a href="#Buffer-Table" class="headerlink" title="Buffer Table"></a>Buffer Table</h2><p>缓冲区表在逻辑上可以分为三个部分：哈希函数(a hash function)，哈希存储桶插槽(hash bucket slots)和数据条目(data entries) (Fig. 8.4)<br>内置的哈希函数将buffer_tags映射到哈希存储桶插槽。由于哈希桶插槽的数量大于缓冲池插槽的数量，会发生冲突。因此，缓冲区表使用单独的链表链接方法来解决冲突。当数据条目(data entries)映射到相同的存储桶插槽(bucket slot)时，此方法将条目存储在相同的链表中，如图8.4所示。</p><p><img data-src="/images/pg_buffer_manager_4.png" alt="Fig. 8.4. Buffer table."></p><p>数据条目包含两个值：页面的buffer_tag和保存页面元数据的描述符的buffer_id。例如，数据条目’Tag_A，id = 1’表示具有buffer_id 1的缓冲区描述符存储带有Tag_A标签的页面的元数据。</p><p><strong>Hash function</strong><br>哈希函数是calc_bucket()和hash()的复合函数。以下是其作为伪函数的表示。<br></p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">uint32 bucket_slot = calc_bucket(<span class="hljs-name">unsigned</span> hash(<span class="hljs-name">BufferTag</span> buffer_tag), uint32 bucket_size)<br></code></pre></td></tr></table></figure><p></p><hr><p>NOTE</p><p>基本操作（查找，插入和删除数据条目）在此不作解释。这些是非常常见的操作，将在以下各节中进行说明。</p><hr><h2 id="Buffer-Descriptor"><a href="#Buffer-Descriptor" class="headerlink" title="Buffer Descriptor"></a>Buffer Descriptor</h2><p>缓冲区描述符的结构在本小节中描述，缓冲区描述符层在下一个小节中</p><p>缓冲区描述符将存储的页面的元数据保存在相应的缓冲池插槽中。缓冲区描述符结构由结构BufferDesc定义。虽然此结构有很多字段，但主要显示在以下字段中：</p><ul><li>tag 将存储页面的buffer_tag保存在相应的缓冲池插槽中（缓冲区标记在第1.2节中定义）</li><li>buffer_id 标识描述符（等效于相应缓冲池插槽的buffer_id）</li><li>refcount 保存当前正在访问关联的存储页面的PostgreSQL进程数。也称为引脚数(pin count)。 PostgreSQL进程访问存储的页面时，其引用计数必须增加1（refcount ++）。访问该页面后，其引用计数必须减少1（refcount—）。<br>当refcount为零时，即当前未访问关联的存储页面，则该页面被取消固定(unpinned)；否则将其固定(pinned.)。</li><li>usage_count 保存关联的存储页面自加载到相应的缓冲池插槽以来已被访问的次数。注意在页面替换算法(page replacement algorithm)中使用了usage_count (Section 4.4).</li><li>context_lock和io_in_progress_lock是轻量级锁，用于控制对关联的存储页面的访问。这些字段在第3.2节中描述。</li><li>flags 保存关联的存储页面的几种状态。主要状态如下:<ul><li>dirty bit 指示存储的页面是否脏.</li><li>valid bit 指示是否可以读取或写入存储的页面（有效）。例如，如果该位有效，则相应的缓冲池插槽将存储一个页面，并且此描述符（有效位）将保存页面元数据；因此，可以读取或写入存储的页面。如果该位无效，则此描述符不包含任何元数据；这意味着无法读取或写入存储的页面，或者缓冲区管理器正在替换存储的页面。</li><li>io_in_progress bit 指示缓冲区管理器是否正在从存储中读取/写入关联页面。换句话说，该位指示单个进程是否持有此描述符的</li></ul></li><li>freeNext 指向下一个描述符以生成空闲列表的指针，这将在下一个小节中进行描述。</li></ul><hr><p><strong>NOTE</strong></p><p>结构 BufferDesc 定义在 src/include/storage/buf_internals.h.</p><hr><p>To simplify the following descriptions, three descriptor states are defined:</p><p>Empty: When the corresponding buffer pool slot does not store a page (i.e. refcount and usage_count are 0), the state of this descriptor is empty.<br>Pinned: When the corresponding buffer pool slot stores a page and any PostgreSQL processes are accessing the page (i.e. refcount and usage_count are greater than or equal to 1), the state of this buffer descriptor is pinned.<br>Unpinned: When the corresponding buffer pool slot stores a page but no PostgreSQL processes are accessing the page (i.e. usage_count is greater than or equal to 1, but refcount is 0), the state of this buffer descriptor is unpinned.</p><p>Each descriptor will have one of the above states. The descriptor state changes relative to particular conditions, which are described in the next subsection.</p><p>In the following figures, buffer descriptors’ states are represented by coloured boxes.</p><p>(white) Empty<br>(blue) Pinned<br>(aqua blue) Unpinned</p><p>In addition, a dirty page is denoted as ‘X’. For example, an unpinned dirty descriptor is represented by X .</p><h2 id="Buffer-Descriptors-Layer"><a href="#Buffer-Descriptors-Layer" class="headerlink" title="Buffer Descriptors Layer"></a>Buffer Descriptors Layer</h2><p>A collection of buffer descriptors forms an array. In this document, the array is referred to as the buffer descriptors layer.</p><p>When the PostgreSQL server starts, the state of all buffer descriptors is empty. In PostgreSQL, those descriptors comprise a linked list called freelist (Fig. 8.5).</p><p><img data-src="/images/pg_buffer_manager_5.png" alt="Fig. 8.5. Buffer manager initial state."></p><hr><p><em>*NOTE</em></p><p>Please note that the freelist in PostgreSQL is completely different concept from the freelists in Oracle. PostgreSQL’s freelist is only linked list of empty buffer descriptors. In PostgreSQL freespace maps, which are described in Section 5.3.4, act as the same role of the freelists in Oracle.</p><hr><p>Figure 8.6 shows that how the first page is loaded.</p><ul><li>Retrieve an empty descriptor from the top of the freelist, and pin it (i.e. increase its refcount and usage_count by 1).</li><li>Insert the new entry, which holds the relation between the tag of the first page and the buffer_id of the retrieved descriptor, in the buffer table.</li><li>Load the new page from storage to the corresponding buffer pool slot.</li><li>Save the metadata of the new page to the retrieved descriptor.</li></ul><p>The second and subsequent pages are loaded in a similar manner. Additional details are provided in Section 8.4.2.</p><p><img data-src="/images/pg_buffer_manager_6.png" alt="Fig. 8.6. Loading the first page."></p><p>Descriptors that have been retrieved from the freelist always hold page’s metadata. In other words, non-empty descriptors continue to be used do not return to the freelist. However, related descriptors are added to the freelist again and the descriptor state becomes ‘empty’ when one of the following occurs:</p><ul><li>Tables or indexes have been dropped.</li><li>Databases have been dropped.</li><li>Tables or indexes have been cleaned up using the VACUUM FULL command.</li></ul><hr><p><strong>Why empty descriptors comprise the freelist?</strong></p><p>The reason why the freelist be made is to get the first descriptor immediately. This is a usual practice for dynamic memory resource allocation. Refer to this description.</p><hr><p>The buffer descriptors layer contains an unsigned 32-bit integer variable, i.e. nextVictimBuffer. This variable is used in the page replacement algorithm described in Section 8.4.4.</p><h2 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h2><p>The buffer pool is a simple array that stores data file pages, such as tables and indexes. Indices of the buffer pool array are referred to as buffer_ids.</p><p>The buffer pool slot size is 8 KB, which is equal to the size of a page. Thus, each slot can store an entire page.</p><h1 id="Buffer-Manager-Locks"><a href="#Buffer-Manager-Locks" class="headerlink" title="Buffer Manager Locks"></a>Buffer Manager Locks</h1><p>The buffer manager uses many locks for many different purposes. This section describes the locks necessary for the explanations in the subsequent sections.</p><hr><p><strong>NOTE</strong></p><p>Please note that the locks described in this section are parts of a synchronization mechanism for the buffer manager; they do not relate to any SQL statements and SQL options.</p><hr><h2 id="Buffer-Table-Locks"><a href="#Buffer-Table-Locks" class="headerlink" title="Buffer Table Locks"></a>Buffer Table Locks</h2><p>BufMappingLock protects the data integrity of the entire buffer table. It is a light-weight lock that can be used in both shared and exclusive modes. When searching an entry in the buffer table, a backend process holds a shared BufMappingLock. When inserting or deleting entries, a backend process holds an exclusive lock.</p><p>The BufMappingLock is split into partitions to reduce the contention in the buffer table (the default is 128 partitions). Each BufMappingLock partition guards the portion of the corresponding hash bucket slots.</p><p>Figure 8.7 shows a typical example of the effect of splitting BufMappingLock. Two backend processes can simultaneously hold respective BufMappingLock partitions in exclusive mode in order to insert new data entries. If the BufMappingLock is a single system-wide lock, both processes should wait for the processing of another process, depending on which started processing.</p><p><img data-src="/images/pg_buffer_manager_7.png" alt="Two processes simultaneously acquire the respective partitions of BufMappingLock in exclusive mode to insert new data entries."></p><p>The buffer table requires many other locks. For example, the buffer table internally uses a spin lock to delete an entry. However, descriptions of these other locks are omitted because they are not required in this document.</p><hr><p><strong>NOTE</strong></p><p>The BufMappingLock had been split into 16 separate locks by default until version 9.4.</p><hr><h2 id="Locks-for-Each-Buffer-Descriptor"><a href="#Locks-for-Each-Buffer-Descriptor" class="headerlink" title="Locks for Each Buffer Descriptor"></a>Locks for Each Buffer Descriptor</h2><p>Each buffer descriptor uses two light-weight locks, content_lock and io_in_progress_lock, to control access to the stored page in the corresponding buffer pool slot. When the values of own fields are checked or changed, a spinlock is used.</p><h3 id="content-lock"><a href="#content-lock" class="headerlink" title="content_lock"></a>content_lock</h3><p>The content_lock is a typical lock that enforces access limits. It can be used in shared and exclusive modes.</p><p>When reading a page, a backend process acquires a shared content_lock of the buffer descriptor that stores the page.</p><p>However, an exclusive content_lock is acquired when doing one of the following:</p><ul><li>Inserting rows (i.e. tuples) into the stored page or changing the t_xmin/t_xmax fields of tuples within the stored page (t_xmin and t_xmax are described in Section 5.2; simply, when deleting or updating rows, these fields of the associated tuples are changed).</li><li>Removing tuples physically or compacting free space on the stored page (performed by vacuum processing and HOT, which are described in Chapters 6 and 7, respectively).</li><li>Freezing tuples within the stored page (freezing is described in Section 5.10.1 and Section 6.3).</li></ul><p>The official <a target="_blank" rel="noopener" href="https://github.com/postgres/postgres/blob/master/src/backend/storage/buffer/README">README</a> file shows more details.</p><h3 id="io-in-progress-lock"><a href="#io-in-progress-lock" class="headerlink" title="io_in_progress_lock"></a>io_in_progress_lock</h3><p>The io_in_progress lock is used to wait for I/O on a buffer to complete. When a PostgreSQL process loads/writes page data from/to storage, the process holds an exclusive io_in_progress lock of the corresponding descriptor while accessing the storage.</p><h3 id="spinlock"><a href="#spinlock" class="headerlink" title="spinlock"></a>spinlock</h3><p>When the flags or other fields (e.g. refcount and usage_count) are checked or changed, a spinlock is used. Two specific examples of spinlock usage are given below:</p><ul><li>The following shows how to pin the buffer descriptor:<ul><li>Acquire a spinlock of the buffer descriptor.</li><li>Increase the values of its refcount and usage_count by 1.</li><li>Release the spinlock.<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">LockBufHdr(<span class="hljs-keyword">bufferdesc); </span>   <span class="hljs-comment">/* Acquire a spinlock */</span><br><span class="hljs-keyword">bufferdesc-&gt;refcont++;</span><br><span class="hljs-keyword">bufferdesc-&gt;usage_count++;</span><br><span class="hljs-keyword">UnlockBufHdr(bufferdesc); </span><span class="hljs-comment">/* Release the spinlock */</span><br></code></pre></td></tr></table></figure></li></ul></li><li>The following shows how to set the dirty bit to ‘1’:<ul><li>Acquire a spinlock of the buffer descriptor.</li><li>Set the dirty bit to ‘1’ using a bitwise operation.</li><li>Release the spinlock.<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">#define BM_DIRTY             (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>)    <span class="hljs-comment">/* data needs writing */</span><br>#define BM_VALID             (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>)    <span class="hljs-comment">/* data is valid */</span><br>#define BM_TAG_VALID         (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>)    <span class="hljs-comment">/* tag is assigned */</span><br>#define BM_IO_IN_PROGRESS    (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>)    <span class="hljs-comment">/* read or write in progress */</span><br>#define BM_JUST_DIRTIED      (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span>)    <span class="hljs-comment">/* dirtied since write started */</span><br><br>LockBufHdr(bufferdesc);<br>bufferdesc-&gt;flags |= BM_DIRTY;<br>UnlockBufHdr(bufferdesc);<br></code></pre></td></tr></table></figure></li></ul></li></ul><p>Changing other bits is performed in the same manner.</p><hr><p><strong>NOTE</strong></p><p>In version 9.6, the spinlocks of buffer manager will be replaced to atomic operations. See this result of <a target="_blank" rel="noopener" href="https://commitfest.postgresql.org/9/408/">commitfest</a>. If you want to know the details, refer to this <a target="_blank" rel="noopener" href="https://www.postgresql.org/message-id/flat/2400449.GjM57CE0Yg@dinodell#2400449.GjM57CE0Yg@dinodell">discussion</a>.</p><hr><h1 id="How-the-Buffer-Manager-Works"><a href="#How-the-Buffer-Manager-Works" class="headerlink" title="How the Buffer Manager Works"></a>How the Buffer Manager Works</h1><p>This section describes how the buffer manager works. When a backend process wants to access a desired page, it calls the ReadBufferExtended function.</p><p>The behavior of the ReadBufferExtended function depends on three logical cases. Each case is described in the following subsections. In addition, the PostgreSQL clock sweep page replacement algorithm is described in the final subsection.</p><h2 id="Accessing-a-Page-Stored-in-the-Buffer-Pool"><a href="#Accessing-a-Page-Stored-in-the-Buffer-Pool" class="headerlink" title="Accessing a Page Stored in the Buffer Pool"></a>Accessing a Page Stored in the Buffer Pool</h2><p>First, the simplest case is described, i.e. the desired page is already stored in the buffer pool. In this case, the buffer manager performs the following steps:</p><ul><li>Create the buffer_tag of the desired page (in this example, the buffer_tag is ‘Tag_C’) and compute the hash bucket slot, which contains the associated entry of the created buffer_tag, using the hash function.</li><li>Acquire the BufMappingLock partition that covers the obtained hash bucket slot in shared mode (this lock will be released in step (5)).</li><li>Look up the entry whose tag is ‘Tag_C’ and obtain the buffer_id from the entry. In this example, the buffer_id is 2.</li><li>Pin the buffer descriptor for buffer_id 2, i.e. the refcount and usage_count of the descriptor are increased by 1 ( Section 8.3.2 describes pinning).</li><li>Release the BufMappingLock.</li><li>Access the buffer pool slot with buffer_id 2.</li></ul><p><img data-src="/images/pg_buffer_manager_8.png" alt="Fig. 8.8. Accessing a page stored in the buffer pool."></p><p>Then, when reading rows from the page in the buffer pool slot, the PostgreSQL process acquires the shared content_lock of the corresponding buffer descriptor. Thus, buffer pool slots can be read by multiple processes simultaneously.</p><p>When inserting (and updating or deleting) rows to the page, a Postgres process acquires the exclusive content_lock of the corresponding buffer descriptor (note that the dirty bit of the page must be set to ‘1’).</p><p>After accessing the pages, the refcount values of the corresponding buffer descriptors are decreased by 1.</p><h2 id="Loading-a-Page-from-Storage-to-Empty-Slot"><a href="#Loading-a-Page-from-Storage-to-Empty-Slot" class="headerlink" title="Loading a Page from Storage to Empty Slot"></a>Loading a Page from Storage to Empty Slot</h2><p>In this second case, assume that the desired page is not in the buffer pool and the freelist has free elements (empty descriptors). In this case, the buffer manager performs the following steps:</p><ul><li>Look up the buffer table (we assume it is not found).</li><li>Create the buffer_tag of the desired page (in this example, the buffer_tag is ‘Tag_E’) and compute the hash bucket slot.</li><li>Acquire the BufMappingLock partition in shared mode.<ul><li>Look up the buffer table (not found according to the assumption).</li><li>Release the BufMappingLock.</li></ul></li><li>Obtain the empty buffer descriptor from the freelist, and pin it. In this example, the buffer_id of the obtained descriptor is 4.</li><li>Acquire the BufMappingLock partition in exclusive mode (this lock will be released in step (6)).</li><li>Create a new data entry that comprises the buffer_tag ‘Tag_E’ and buffer_id 4; insert the created entry to the buffer table.</li><li>Load the desired page data from storage to the buffer pool slot with buffer_id 4 as follows:</li><li>Acquire the exclusive io_in_progress_lock of the corresponding descriptor.<ul><li>Set the io_in_progress bit of the corresponding descriptor to ‘1 to prevent access by other processes.</li><li>Load the desired page data from storage to the buffer pool slot.</li><li>Change the states of the corresponding descriptor; the io_in_progress bit is set to ‘0’, and the valid bit is set to ‘1’.</li><li>Release the io_in_progress_lock.</li></ul></li><li>Release the BufMappingLock.</li><li>Access the buffer pool slot with buffer_id 4.</li></ul><p><img data-src="/images/pg_buffer_manager_9.png" alt="Fig. 8.9. Loading a page from storage to an empty slot."></p><h2 id="Loading-a-Page-from-Storage-to-a-Victim-Buffer-Pool-Slot"><a href="#Loading-a-Page-from-Storage-to-a-Victim-Buffer-Pool-Slot" class="headerlink" title="Loading a Page from Storage to a Victim Buffer Pool Slot"></a>Loading a Page from Storage to a Victim Buffer Pool Slot</h2><p>In this case, assume that all buffer pool slots are occupied by pages but the desired page is not stored. The buffer manager performs the following steps:</p><ul><li>Create the buffer_tag of the desired page and look up the buffer table. In this example, we assume that the buffer_tag is ‘Tag_M’ (the desired page is not found).</li><li>Select a victim buffer pool slot using the clock-sweep algorithm, obtain the old entry, which contains the buffer_id of the victim pool slot, from the buffer table and pin the victim pool slot in the buffer descriptors layer. In this example, the buffer_id of the victim slot is 5 and the old entry is ‘Tag_F, id=5’. The clock sweep is described in the next subsection.</li><li>Flush (write and fsync) the victim page data if it is dirty; otherwise proceed to step (4).<br>The dirty page must be written to storage before overwriting with new data. Flushing a dirty page is performed as follows:<ul><li>Acquire the shared content_lock and the exclusive io_in_progress lock of the descriptor with buffer_id 5 (released in step 6).</li><li>Change the states of the corresponding descriptor; the io_in_progress bit is set to ‘1’ and the just_dirtied bit is set to ‘0’.</li><li>Depending on the situation, the XLogFlush() function is invoked to write WAL data on the WAL buffer to the current WAL segment file (details are omitted; WAL and the XLogFlush function are described in Chapter 9).</li><li>Flush the victim page data to storage.</li><li>Change the states of the corresponding descriptor; the io_in_progress bit is set to ‘0’ and the valid bit is set to ‘1’.</li><li>Release the io_in_progress and content_lock locks.</li></ul></li><li>Acquire the old BufMappingLock partition that covers the slot that contains the old entry, in exclusive mode.</li><li>Acquire the new BufMappingLock partition and insert the new entry to the buffer table:<ul><li>Create the new entry comprised of the new buffer_tag ‘Tag_M’ and the victim’s buffer_id.</li><li>Acquire the new BufMappingLock partition that covers the slot containing the new entry in exclusive mode.</li><li>Insert the new entry to the buffer table.</li></ul></li><li>Delete the old entry from the buffer table, and release the old BufMappingLock partition.</li><li>Load the desired page data from the storage to the victim buffer slot. Then, update the flags of the descriptor with buffer_id 5; the dirty bit is set to ‘0 and initialize other bits.</li><li>Release the new BufMappingLock partition.</li><li>Access the buffer pool slot with buffer_id 5.</li></ul><p><img data-src="/images/pg_buffer_manager_10.png" alt="Fig. 8.10. Loading a page from storage to a victim buffer pool slot."></p><h2 id="Page-Replacement-Algorithm-Clock-Sweep"><a href="#Page-Replacement-Algorithm-Clock-Sweep" class="headerlink" title="Page Replacement Algorithm: Clock Sweep"></a>Page Replacement Algorithm: Clock Sweep</h2><p>The rest of this section describes the clock-sweep algorithm. This algorithm is a variant of NFU (Not Frequently Used) with low overhead; it selects less frequently used pages efficiently.</p><p>Imagine buffer descriptors as a circular list (Fig. 8.12). The nextVictimBuffer, an unsigned 32-bit integer, is always pointing to one of the buffer descriptors and rotates clockwise. The pseudocode and description of the algorithm are follows:</p><hr><p><strong>Pseudocode: clock-sweep</strong></p><h2><a href="#" class="headerlink"></a><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">     <span class="hljs-keyword">WHILE</span> <span class="hljs-literal">true</span><br>(<span class="hljs-number">1</span>)     Obtain the candidate <span class="hljs-keyword">buffer</span> descriptor pointed by the nextVictimBuffer<br>(<span class="hljs-number">2</span>)     <span class="hljs-keyword">IF</span> the candidate descriptor <span class="hljs-keyword">is</span> unpinned <span class="hljs-keyword">THEN</span><br>(<span class="hljs-number">3</span>)           <span class="hljs-keyword">IF</span> the candidate descriptor<span class="hljs-symbol">&#x27;s</span> usage_count == <span class="hljs-number">0</span> <span class="hljs-keyword">THEN</span><br>                BREAK <span class="hljs-keyword">WHILE</span> <span class="hljs-keyword">LOOP</span>  <span class="hljs-comment">/* the corresponding slot of this descriptor is victim slot. */</span><br>           <span class="hljs-keyword">ELSE</span><br>            Decrease the candidate descriptpor<span class="hljs-symbol">&#x27;s</span> usage_count by <span class="hljs-number">1</span><br>               <span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span><br>         <span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span><br>(<span class="hljs-number">4</span>)     Advance nextVictimBuffer <span class="hljs-keyword">to</span> the <span class="hljs-keyword">next</span> one<br>      <span class="hljs-keyword">END</span> <span class="hljs-keyword">WHILE</span> <br>(<span class="hljs-number">5</span>) <span class="hljs-keyword">RETURN</span> buffer_id <span class="hljs-keyword">of</span> the victim<br></code></pre></td></tr></table></figure></h2><p>A specific example is shown in Fig. 8.12. The buffer descriptors are shown as blue or cyan boxes, and the numbers in the boxes show the usage_count of each descriptor.</p><h1 id="Ring-Buffer"><a href="#Ring-Buffer" class="headerlink" title="Ring Buffer"></a>Ring Buffer</h1><p>When reading or writing a huge table, PostgreSQL uses a ring buffer rather than the buffer pool. The ring buffer is a small and temporary buffer area. When any condition listed below is met, a ring buffer is allocated to shared memory:</p><ul><li>Bulk-reading<br>When a relation whose size exceeds one-quarter of the buffer pool size (shared_buffers/4) is scanned. In this case, the ring buffer size is 256 KB.</li><li>Bulk-writing<br>When the SQL commands listed below are executed. In this case, the ring buffer size is 16 MB.<ul><li>COPY FROM command.</li><li>CREATE TABLE AS command.</li><li>CREATE MATERIALIZED VIEW or REFRESH MATERIALIZED VIEW command.</li><li>ALTER TABLE command.</li></ul></li><li>Vacuum-processing<br>When an autovacuum performs a vacuum processing. In this case, the ring buffer size is 256 KB.</li></ul><p>The allocated ring buffer is released immediately after use.</p><p>The benefit of the ring buffer is obvious. If a backend process reads a huge table without using a ring buffer, all stored pages in the buffer pool are removed (kicked out); therefore, the cache hit ratio decreases. The ring buffer avoids this issue.</p><hr><p><strong>Why the default ring buffer size for bulk-reading and vacuum processing is 256 KB?</strong></p><p>Why 256 KB? The answer is explained in the <a target="_blank" rel="noopener" href="https://github.com/postgres/postgres/blob/master/src/backend/storage/buffer/README">README</a> located under the buffer manager’s source directory.<br>For sequential scans, a 256 KB ring is used. That’s small enough to fit in L2 cache, which makes transferring pages from OS cache to shared buffer cache efficient. Even less would often be enough, but the ring must be big enough to accommodate all pages in the scan that are pinned concurrently. (snip)</p><hr><h1 id="Flushing-Dirty-Pages-1"><a href="#Flushing-Dirty-Pages-1" class="headerlink" title="Flushing Dirty Pages"></a>Flushing Dirty Pages</h1><p>In addition to replacing victim pages, the checkpointer and background writer processes flush dirty pages to storage. Both processes have the same function (flushing dirty pages); however, they have different roles and behaviours.</p><p>The checkpointer process writes a checkpoint record to the WAL segment file and flushes dirty pages whenever checkpointing starts. Section 9.7 describes checkpointing and when it begins.</p><p>The role of the background writer is to reduce the influence of the intensive writing of checkpointing. The background writer continues to flush dirty pages little by little with minimal impact on database activity. By default, the background writer wakes every 200 msec (defined by bgwriter_delay) and flushes bgwriter_lru_maxpages (the default is 100 pages) at maximum.</p><hr><p><strong>为什么要从background writer分离出checkpointer?</strong></p><p>在9.1或更早版本中，background writer定期执行checkpoint处理。在版本9.2中，checkpointer进程已与background writer进程分离。在<a target="_blank" rel="noopener" href="https://www.postgresql.org/message-id/CA%2BU5nMLv2ah-HNHaQ%3D2rxhp_hDJ9jcf-LL2kW3sE4msfnUw9gA%40mail.gmail.com">“Separating bgwriter and checkpointer”</a> 提案中描述了原因。</p><h2 id="-1"><a href="#-1" class="headerlink"></a><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">Currently(<span class="hljs-keyword">in</span> <span class="hljs-number">2011</span>) <span class="hljs-keyword">the</span> bgwriter process performs both background writing, checkpointing <span class="hljs-keyword">and</span> <span class="hljs-keyword">some</span> other duties. This means <span class="hljs-keyword">that</span> we can&#x27;t perform <span class="hljs-keyword">the</span> final checkpoint fsync <span class="hljs-keyword">without</span> stopping background writing, so there <span class="hljs-keyword">is</span> a negative performance effect <span class="hljs-keyword">from</span> doing both things <span class="hljs-keyword">in</span> one process.<br>Additionally, our aim <span class="hljs-keyword">in</span> <span class="hljs-number">9.2</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">to</span> replace polling loops <span class="hljs-keyword">with</span> latches <span class="hljs-keyword">for</span> power reduction. The complexity <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> bgwriter loops <span class="hljs-keyword">is</span> high <span class="hljs-keyword">and</span> <span class="hljs-keyword">it</span> seems unlikely <span class="hljs-keyword">to</span> come up <span class="hljs-keyword">with</span> a clean approach using latches.<br></code></pre></td></tr></table></figure></h2></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div class="reward-container"><div>听说，打赏我的人都找到了真爱</div><button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'>打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/wechatpay.png" alt="daydayup 微信支付"><p>微信支付</p></div><div style="display:inline-block"><img src="/images/alipay.png" alt="daydayup 支付宝"><p>支付宝</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>daydayup</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="http://daydayup863.github.io/PostgreSQL/PostgreSQL_Buffer_Manager/" title="PostgreSQL 缓冲区管理">http://daydayup863.github.io/PostgreSQL/PostgreSQL_Buffer_Manager/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"><p>欢迎关注我的其它发布渠道</p><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="/atom.xml"><span class="icon"><i class="fa fa-rss"></i> </span><span class="label">RSS</span></a></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/PostgreSQL/" rel="tag"><i class="fa fa-tag"></i> PostgreSQL</a> <a href="/tags/buffer/" rel="tag"><i class="fa fa-tag"></i> buffer</a></div><div class="post-nav"><div class="post-nav-item"><a href="/Linux/Linux_cmd_summary/" rel="prev" title="Linux 命令记录"><i class="fa fa-chevron-left"></i> Linux 命令记录</a></div><div class="post-nav-item"><a href="/PostgreSQL/PostgreSQL_vacuum/" rel="next" title="PostgreSQL vacuum">PostgreSQL vacuum <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><div><canvas id="canvas" style="width:60%">当前浏览器不支持canvas，请更换浏览器后再试</canvas></div><script>!function(){var o,a,r,f,t,i=[[[0,0,1,1,1,0,0],[0,1,1,0,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,0,1,1,0],[0,0,1,1,1,0,0]],[[0,0,0,1,1,0,0],[0,1,1,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[1,1,1,1,1,1,1]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,1,1,0,0,0],[0,1,1,0,0,0,0],[1,1,0,0,0,0,0],[1,1,0,0,0,1,1],[1,1,1,1,1,1,1]],[[1,1,1,1,1,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,1,1,0],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,0,0,0,1,1,0],[0,0,0,1,1,1,0],[0,0,1,1,1,1,0],[0,1,1,0,1,1,0],[1,1,0,0,1,1,0],[1,1,1,1,1,1,1],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,1,1,1,1]],[[1,1,1,1,1,1,1],[1,1,0,0,0,0,0],[1,1,0,0,0,0,0],[1,1,1,1,1,1,0],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,0,0,0,1,1,0],[0,0,1,1,0,0,0],[0,1,1,0,0,0,0],[1,1,0,0,0,0,0],[1,1,0,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[1,1,1,1,1,1,1],[1,1,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,1,1,0,0,0,0]],[[0,0,0,0,0,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,0,0,0]]],e=document.getElementById("canvas");function h(t,e){for(var n=[1,2,3],l=["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"],o=0;o<i[e].length;o++)for(var a,h=0;h<i[e][o].length;h++){1==i[e][o][h]&&(a={x:14*(f+2)*t+2*h*(f+1)+(f+1),y:2*o*(f+1)+(f+1),stepX:Math.floor(4*Math.random()-2),stepY:-2*n[Math.floor(Math.random()*n.length)],color:l[Math.floor(Math.random()*l.length)],disY:1},r.push(a))}}function n(){e.height=100;for(var t=0;t<a.length;t++)!function(t,e){for(var n=0;n<i[e].length;n++)for(var l=0;l<i[e][n].length;l++)1==i[e][n][l]&&(o.beginPath(),o.arc(14*(f+2)*t+2*l*(f+1)+(f+1),2*n*(f+1)+(f+1),f,0,2*Math.PI),o.closePath(),o.fill())}(t,a[t]);for(t=0;t<r.length;t++)o.beginPath(),o.arc(r[t].x,r[t].y,f,0,2*Math.PI),o.fillStyle=r[t].color,o.closePath(),o.fill()}e.getContext&&(o=e.getContext("2d"),e.height=100,e.width=700,o.fillStyle="#f00",o.fillRect(10,10,50,50),a=[],r=[],f=e.height/20-1,t=/(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date),a.push(t[1],t[2],10,t[3],t[4],10,t[5],t[6]),clearInterval(void 0),setInterval(function(){!function(){var t=[],e=/(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date),n=[];n.push(e[1],e[2],10,e[3],e[4],10,e[5],e[6]);for(var l=a.length-1;0<=l;l--)n[l]!==a[l]&&t.push(l+"_"+(Number(a[l])+1)%10);for(l=0;l<t.length;l++)h.apply(this,t[l].split("_"));a=n.concat()}(),function(){for(var t=0;t<r.length;t++)r[t].stepY+=r[t].disY,r[t].x+=r[t].stepX,r[t].y+=r[t].stepY,(r[t].x>700+f||r[t].y>100+f)&&(r.splice(t,1),t--)}(),n()},50))}()</script><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Overview"><span class="nav-number">1.</span> <span class="nav-text">Overview</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Buffer-Manager-Structure"><span class="nav-number">1.1.</span> <span class="nav-text">Buffer Manager Structure</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Buffer-Tag"><span class="nav-number">1.2.</span> <span class="nav-text">Buffer Tag</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#How-a-Backend-Process-Reads-Pages"><span class="nav-number">1.3.</span> <span class="nav-text">How a Backend Process Reads Pages</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Page-Replacement-Algorithm"><span class="nav-number">1.4.</span> <span class="nav-text">Page Replacement Algorithm</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Flushing-Dirty-Pages"><span class="nav-number">1.5.</span> <span class="nav-text">Flushing Dirty Pages</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Buffer-Manager-Structure-1"><span class="nav-number">2.</span> <span class="nav-text">Buffer Manager Structure</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Buffer-Table"><span class="nav-number">2.1.</span> <span class="nav-text">Buffer Table</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Buffer-Descriptor"><span class="nav-number">2.2.</span> <span class="nav-text">Buffer Descriptor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Buffer-Descriptors-Layer"><span class="nav-number">2.3.</span> <span class="nav-text">Buffer Descriptors Layer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Buffer-Pool"><span class="nav-number">2.4.</span> <span class="nav-text">Buffer Pool</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Buffer-Manager-Locks"><span class="nav-number">3.</span> <span class="nav-text">Buffer Manager Locks</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Buffer-Table-Locks"><span class="nav-number">3.1.</span> <span class="nav-text">Buffer Table Locks</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Locks-for-Each-Buffer-Descriptor"><span class="nav-number">3.2.</span> <span class="nav-text">Locks for Each Buffer Descriptor</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#content-lock"><span class="nav-number">3.2.1.</span> <span class="nav-text">content_lock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#io-in-progress-lock"><span class="nav-number">3.2.2.</span> <span class="nav-text">io_in_progress_lock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spinlock"><span class="nav-number">3.2.3.</span> <span class="nav-text">spinlock</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#How-the-Buffer-Manager-Works"><span class="nav-number">4.</span> <span class="nav-text">How the Buffer Manager Works</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Accessing-a-Page-Stored-in-the-Buffer-Pool"><span class="nav-number">4.1.</span> <span class="nav-text">Accessing a Page Stored in the Buffer Pool</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Loading-a-Page-from-Storage-to-Empty-Slot"><span class="nav-number">4.2.</span> <span class="nav-text">Loading a Page from Storage to Empty Slot</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Loading-a-Page-from-Storage-to-a-Victim-Buffer-Pool-Slot"><span class="nav-number">4.3.</span> <span class="nav-text">Loading a Page from Storage to a Victim Buffer Pool Slot</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Page-Replacement-Algorithm-Clock-Sweep"><span class="nav-number">4.4.</span> <span class="nav-text">Page Replacement Algorithm: Clock Sweep</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">4.5.</span> <span class="nav-text">1 2 3 4 5 6 7 8 9 10 11 12 WHILE true (1) Obtain the candidate buffer descriptor pointed by the nextVictimBuffer (2) IF the candidate descriptor is unpinned THEN (3) IF the candidate descriptor&amp;#x27;s usage_count &#x3D;&#x3D; 0 THEN BREAK WHILE LOOP &#x2F;* the corresponding slot of this descriptor is victim slot. *&#x2F; ELSE Decrease the candidate descriptpor&amp;#x27;s usage_count by 1 END IF END IF (4) Advance nextVictimBuffer to the next one END WHILE (5) RETURN buffer_id of the victim</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Ring-Buffer"><span class="nav-number">5.</span> <span class="nav-text">Ring Buffer</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Flushing-Dirty-Pages-1"><span class="nav-number">6.</span> <span class="nav-text">Flushing Dirty Pages</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#-1"><span class="nav-number">6.1.</span> <span class="nav-text">1 2 Currently(in 2011) the bgwriter process performs both background writing, checkpointing and some other duties. This means that we can&amp;#x27;t perform the final checkpoint fsync without stopping background writing, so there is a negative performance effect from doing both things in one process. Additionally, our aim in 9.2 is to replace polling loops with latches for power reduction. The complexity of the bgwriter loops is high and it seems unlikely to come up with a clean approach using latches.</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><a href="/"><img class="site-author-image" itemprop="image" alt="daydayup" src="/images/user.jpg"></a><p class="site-author-name" itemprop="name">daydayup</p><div class="site-description" itemprop="description">good good study, day day up.</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">52</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">46</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">73</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/daydayup863" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;daydayup863" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i> 大神链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://github.com/digoal/blog" title="https:&#x2F;&#x2F;github.com&#x2F;digoal&#x2F;blog" rel="noopener" target="_blank">德哥</a></li><li class="links-of-blogroll-item"><a href="https://postgres.fun/" title="https:&#x2F;&#x2F;postgres.fun" rel="noopener" target="_blank">francs</a></li><li class="links-of-blogroll-item"><a href="https://pengzhanyuan.github.io/" title="https:&#x2F;&#x2F;pengzhanyuan.github.io&#x2F;" rel="noopener" target="_blank">元叔</a></li></ul></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2021</span> <span class="with-love" id="heart"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">daydayup</span></div><div class="powered-by"><i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv"> 本站访客数:<span id="busuanzi_value_site_uv"></span></span></div><br><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div><br><div class="theme-info"><div class="powered-by"></div><span class="post-count">博客全站共50.3k字</span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/local-search.js"></script><script src="/js/cursor/cherry.js"></script><div id="needsharebutton-float"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script><script>flOptions={iconStyle:"default",boxForm:"horizontal",position:"middleRight",networks:"Weibo,Wechat,Douban,QQZone,Twitter,Facebook"},new needShareButton("#needsharebutton-float",flOptions)</script><script>NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : '3i88YSkCct0TI3n9fK42pDqp-gzGzoHsz',
      appKey     : 'HAU6P1j8dEW9P7oMKHQsS0Ub',
      placeholder: "在这里说点什么吧...",
      avatar     : 'wavatar',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});</script><script type="text/javascript" src="/js/love.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/haruto.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!0}})</script></body></html>